# S-A-C: Simple Anti Crawler
**English** | [ä¸­æ–‡](./README.md)
---
A simple and lightweight web anti-crawler implementation

> Just add dozens of lines of JavaScript code (before encryption) to the front end to add safe and effective protection measures to your web interface service.

**You can take the [online test](https://test.zhuyansong.com) on this page**
## ðŸ”°ðŸ›¡Shielding linkðŸ›¡ðŸ”°
- The implementation code of this project is extremely simple, only providing an idea, and the business logic needs to be expanded by yourself
- This project can theoretically prevent malicious requests to the interface, but the security depends on your JS encryption of the front-end page, and it cannot guarantee security 100%
- The device fingerprint of this project cannot detect fingerprint browsers, because it aims to achieve a zero-cost protection for the website interface rather than as a browser fingerprint detection

## Purpose

At present, many personal webmasters provide various services to users. However, in reality, public interfaces are often easily called and crawled in large quantities, which may deviate from the original intention of the webmaster, causing the interface to be abused or appear in places where it should not appear.

We want to avoid this situation, but we donâ€™t want to bear the price of third-party defenses such as behavioral verification codes, nor do we want to spend time and effort to study how to prevent the interface from being abused.

Now, SAC can solve this problem well, and it can also obtain device fingerprint information for user behavior analysis.

> [!CAUTION]
> ! Note: The security of this solution is based on the obfuscation encryption of your front-end code. The more difficult it is to reverse the obfuscation of your front-end code, the more difficult it is to break through your anti-crawling strategy!

## Detailed explanation of the solution

By using the **document, window, navigator** provided by the browser and **canvas** to obtain **WebGL**L information, we can use JavaScript to process this data, encrypt the data string into a token, and pass it to the backend through headers or cookies. Verify it through the backend logic.

The current solution allows the backend to easily verify from **four dimensions***

- Encryption verification
- Time verification
- Fingerprint verification
- Interface verification

### Encryption verification
The frontend encrypts the data string into a token through a specific encryption method (AES/DES) and decrypts it on the backend. This can effectively prevent forged tokens.

### Time verification
After completing the encryption verification, the backend can extract the timestamp passed in by the frontend from the decrypted data, and verify it according to the expiration time set by the backend. If it times out, the token can be deemed expired. Effectively prevent multiple batch requests for a token.

### Fingerprint verification
We can use this method to detect abnormal user operations. After the token is decrypted, there is a unique device ID generated by the frontend, which is generated by some browser fingerprints. The backend can determine the account risk based on whether the account logs in to multiple device IDs at the same time. If there is no account system, the request frequency of the same device ID within a period of time can be directly limited.

### Interface verification
After passing the first three verifications, the credibility of the request is already very high. However, one thing we cannot ignore is that if a user uses a token to request multiple interfaces at the same time in a short period of time, malicious requests may still be formed. Therefore, we can verify the interface path generated by the frontend when initiating the request and the submitted data to determine whether this token is used for the current interface.

## Interaction solution

As mentioned earlier, it can be passed to the backend through headers or cookies. This is to achieve the best strategy in different scenarios.

### Token passed in headers
The method of passing in tokens through headers can fully complete the above four verifications, but it may cause certain performance losses. The following cookie passing method will explain this reason.

The header passing method can be used to fight anti-crawling
### Token passed in cookies
If the token is passed in through headers, there is an inevitable problem. That is, each time the front-end initiates a request, a token needs to be generated. For security reasons, although the front-end code is only a few dozen lines, it is often necessary to use VMP encryption technology, obfuscation and other solutions to reinforce the code, which will cause performance loss when the front-end requests.

Therefore, when the interface request frequency is too high, we can generate a device token and pass it to the back-end. After the back-end completes the verification, a cookie is returned. This cookie is attached to all subsequent requests without generating a token. This can effectively prevent user performance loss. However, the interface verification capability will also be lost.

The cookie input method can be used to record device fingerprints and analyze user behavior.

## Data string interpretation

The data string generally generated by the front end is as follows, with comments attached
```json
{
"x0": 1739777674361, //Timestamp
"x1": "Google Inc. (Intel)ANGLE (Intel, Intel(R) UHD Graphics (0x0000A720) Direct3D11 vs_5_0 ps_5_0, D3D11)", //WebGL information
"x2": "Win32", //System or hardware platform
"x3": 1920, //Screen resolution (x)
"x4": 1080, //Screen resolution (y)
"x5": 24, //Device bit depth
"x6": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36", //UA
"x7": 16, //CPU core
"x8": "zh-CN", //Language
"x9": 8, //Estimated total RAM
"x10": "Asia/Shanghai", //Time zone
"x11": [], //Font information
"x12": "bea060aa90462ebdc4e52e1f00b3c16d", //Device fingerprint
"x13": "/check.php", //Request interface Business logic is passed in
"x14": "example" //Submit data Business logic is passed in
}
```

## Example
SAC provides examples of front-end JavaScript and examples of commonly used server-side development languages â€‹â€‹for the back-end.

The front-end example is located in the JavaScript directory of the root directory. The back-end example is as follows. â”œâ”€Server
| â”œâ”€Ruby
| | â””Example.rb
| â”œâ”€Python
| | â””Example.py
| â”œâ”€PHP
| | â””Example.php
| â”œâ”€Nodejs
| | â””Example.js
| â”œâ”€Java
| | â””Example.java
| â”œâ”€Go
| | â””Example.go
| â”œâ”€C#
| | â””Example.cs
```
## Usage examples

---
### Front-end
**Introduce the front-end JavaScript code into your front-end code, please be sure to encrypt**

To use, please make sure you import the **CryptoJS** library

You can choose different ways to import according to your development situation

#### CDN introduction
```javascript
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1-crypto-js.js"></script>
```

#### Install and import
```bash
npm install crypto-js
```
Then import and use in your Vue component
```vue
import CryptoJS from 'crypto-js';
```
Next, you can use it in your business logic

```javascript
const deviceInfo = new DeviceInfo(customSecretKey, customIv);
const encryptedData = deviceInfo.getDevice('/path', 'some data');
console.log(encryptedData);
```
Generate and pass in as headers parameter when requesting the interface
```javascript
const headers = new Headers({
"Content-Type": "application/json",
"gid": deviceInfo.getDevice('/api', JSON.stringify({ data: 'example' })) // Append deviceId as the gid field
});

// Example: Send a request using fetch with headers
fetch('/api', {
method: 'POST',
headers: headers,
body: JSON.stringify({ data: 'example' }) // Sample request data
})
.then(response => response.json())
.then(data => {
//Business logic for successful request
})
.catch(error => console.error('Request failed:', error));
```
### Backend
Please refer to the corresponding sample code to introduce business logic according to your language

The following is the four-factor verification of headers using Python
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib
import base64
import json
import time

# Set the key and IV
secret_key = b'testkey123456789' # 16-byte key
iv = b'testiv1234567890' # 16-byte IV

# Data to be decrypted
encrypted_data = 'SAC_uDSKBeOt/ytQAY0no23aeqzfXOs27vCJz2bbNIk3XpDs8ya0K+wu9I/ThxXQzwS3v6RlIoVz6vPh7pIarlR8XUdXGDTzrrLll jOR5HtRNfumfY1xExuaKIRYdZ6LrwU5t6UDRtV5FvQJ0994yI8U2W0IPcuIO2bwDsun3t0Iuf3hVUOGh0urTTjMNCjtbwDyTuccdSke ZxslRR16vDuG8kEAfgl22UM5kJeLmCTyLJyzj9PCur/KnRMHPNJqSX5TVaFV5Uu2mHSnDOOS5mzzPROk3O+8C3gOM7DIw/6+fL+y9kn DRtC5FV1KZcQNJ7Lqudug5fM4RuYtaUmMflXyhF0wymOWVCZD3QfLz9yXyYnkwxk61nvXuNLCBgjDoCDXX9HsXnBtOuF0CC/nZmgUBX O6mZLlzTYGOSHAxNAjaINJ0UwFdFl7aeL0XVV++zr+Hny4DMel2EytnuZ/KMEYzRYvqUpBFBCQRdOJ1i7Ki9VENBqV+f2KTAk8NSlM qUqKuh3TpOZvAwSobcVZcZBuYlkpSF0LFKUMXyjyiHWuaTG1ocdQrhgCQPBoM0HX0vMku3ebdXDGzAZmXPJle+caNPQ4UZPAIP2zzSz v+1uCx1OWXNmp4NOtCDXRBWyc3JvYQVyawJEC4grO3UNBzlHMUVso3HRgy99duDqlw2bv8wnUHp7G1mCAnwKdLKlpnb0t0yJw6vfc11xi7p/c6O5XWFYg9/EyAqPebS/LZRuASRxwt71i2neRgXYoPrF7fwosSAhP2R4kmp8f0znTBtKZTQ=='

#Remove identification characters
encrypted_data = encrypted_data[4:]

# Decryption
cipher = AES.new(secret_key, AES.MODE_CBC, iv)
try:
    decrypted_data = unpad(cipher.decrypt(base64.b64decode(encrypted_data)), AES.block_size)
    print("Encryption verification passed")
except ValueError:
    print("Encryption verification failed")
    exit()
# Decrypted is a Base64-encoded JSON string
decoded_json_base64 = decrypted_data.decode('utf-8')

# Decode Base64 string
device_json = json.loads(base64.b64decode(decoded_json_base64).decode('utf-8'))

# Output decoded device_json
# print(device_json)

# Verify that the timestamp is within the validity period (set the time range within 60 seconds)
time_range = 60
if device_json['x0'] < int(time.time()*1000) <= device_json['x0'] + time_range*1000:
    print("Time verification passed")
else:
    print("Time verification failed")

# Verify fingerprint authenticity (if necessary)
x12 = str(device_json['x1'])+str(device_json['x2'])+str(device_json['x3'])+str(device_json['x4'])+str(device_json['x5'])+str(device_json['x7'])+str(device_json['x9'])
md5_hash = hashlib.md5()
md5_hash.update(x12.encode('utf-8'))
if device_json['x12'] == md5_hash.hexdigest():
    print("Fingerprint verification passed")
else:
    print("Fingerprint verification failed")

#Check whether the interface and DATA match (if necessary). Please check the path and data of the actual request in actual use
path = str(device_json['x13'])
data = str(device_json['x14'])
if path=='/check.php' and data=='{\"data\":\"example\"}':
    print("Interface verification passed")
else:
    print("Interface verification failed")
```
In actual use, you only need to configure key and iv, then extract encrypted_data from headers, and then use the remaining logic to verify and complete the business logic. If the verification fails, you can directly return 403. 